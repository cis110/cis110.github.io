program LinkedListTOY
// Benedict Brown
// Input:    List of numbers (unsorted)
// Output:   List of numbers (sorted)
// Remarks:  Inserts numbers into a linked list in sorted order
//           Then prints them out
//
//           Memory address 00 is used to represent null
//           Linked list nodes are stored started at memory address 80
// -----------------------------------------------------------------------------

Register Map:
R[1] - constant 1
R[2] - constant 2
R[3] - valsLeftToRead
R[4] - newVal

R[5] - scratch

R[A] - address of head
R[B] - address of mem[nextMemIndex] (and mem[nextMemIndex].val
R[C] - address of mem[nextMemIndex].next
R[D] - address of current node (and and of node.val)
R[E] - node.next
R[F] - node.val/node.next.val/head.val

00: 0000   (0000 0000 0000 0000,      0) reserved to represent null

// initialization
10: 7101   R[1] <- 0001                  constant 1
11: 7202   R[2] <- 0002                  constant 2
12: 7A00   R[A] <- 0000                  head = null
13: 7B80   R[B] <- 0080                  next free node location = 80

14: 83FF   read R[3]                     no of input values (n), read from StdIn

// make sure n > 0, otherwise halt
15: D317   if (R[3] > 0) goto 17         skip halt instruction if n > 0
16: 0000   halt                          

// main loop to read values and insert them into linked list
// assumes valsLeftToRead > 0 because of previous check
17: 84FF   read R[4]                     read one input value

// create a node
18: B40B   mem[R[B]] <- R[4]             mem[nextMemIndex]
19: 1CB1   R[C] <- R[B] + R[1]           pointer to mem[nextMemIndex].next

1A: DA1E   if (R[A] > 0) goto 1E         if (head == null)
1B: 4AB0   R[A] <- R[B]                     head = node we are creating
1C: B00C   mem[R[C]] <- R[0]                set next pointer to 0 (null)
1D: C031   goto 31                       else

1E: AF0A   R[F] <- mem[R[A]]               head.val
1F: 254F   R[5] <- R[4] - R[F]             newVal - head.val

20: D524   if (R[5] > 0) goto 24           if (newVal <= head.val)
21: BA0C   mem[R[C]] <- R[A]                 mem[nextMemIndex].next = head
22: 4AB0   R[A] <- R[B]                      head = mem[nextMemIndex]

23: C031   goto 31                         else
24: 4DA0   R[D] <- R[A]                      node = head
25: 15D1   R[5] <- R[D] + R[1]               address of node.next
26: AE05   R[E] <- mem[R[5]]                 node.next
27: CE2E   if (R[E] == 0) goto 2E            while (node.next != null)
28: AF0E   R[F] <- mem[R[E]]                   node.next.val
29: 25F4   R[5] <- R[F] - R[4]                 newVal - node.next.val

2A: D52E   if (R[5] > 0) goto 2E               if (node.next.val > newVal) break
2B: 1000   no-op                         

2C: 4DE0   R[D] <- R[E]                        node = node.next
2D: C027   goto 27                           end while

2E: BE0C   mem[R[C]] <- R[E]                 mem[nextMemIndex].next = node.next
2F: 15D1   R[5] <- R[D] + R[1]               address of node.next
30: BB05   mem[R[5]] <- R[B]                 node.next = mem[nextMemIndex]
                                           end if
                                         end if

31: 2331   R[3] <- R[3] - R[1]           valsLeftToRead--
32: 1BB2   R[B] <- R[B] + R[2]           address of next available node += 2
                                           (nextMemIndex++)
33: D317   if (R[3] > 0) goto 17         loop if valsLeftToRead > 0

// loop to print out values
// assumes head != null because we read at least one value
34: AF0A   R[F] <- mem[R[A]]             head.val
35: 9FFF   write R[F]                    System.out.println(head.val)
36: 15A1   R[5] <- R[A] + R[1]           address of head.next
37: AA05   R[A] <- mem[R[5]]             head = head.next
38: DA34   if (R[A] > 0) goto 34         loop if head != null
39: 0000   halt                          
